#!/usr/bin/perl -w

# $Id$
#
# fedora-ds-graph -- An rrdtool-based graphing tool for Fedora DS statistics
# copyright (c) 2006-2008 Chris St. Pierre <stpierre@nebrwesleyan.edu>
# based on mailgraph copyright (c) 2000-2005 David Schweikert <dws@ee.ethz.ch>
# released under the GNU General Public License

######## Parse::FDSlog 0.1 ########
package Parse::FDSlog;
use Carp;
use Symbol;
use Time::Local;
use strict;
use vars qw($VERSION);
my %months_map = (
    'jan' => 0, 'feb' => 1, 'mar' => 2,
    'apr' => 3, 'may' => 4, 'jun' => 5,
    'jul' => 6, 'aug' => 7, 'sep' => 8,
    'oct' => 9, 'nov' =>10, 'dec' =>11,
    );
# year-increment algorithm: if in january, if december is seen, decrement year
my $enable_year_decrement = 1;
# fast timelocal, cache minute's timestamp
# don't cache more than minute because of daylight saving time switch
my @str2time_last_minute;
my $str2time_last_minute_timestamp;
# 0: sec, 1: min, 2: h, 3: day, 4: month, 5: year

sub str2time($$$$$$$) {
    my $GMT = pop @_;
    if(defined $str2time_last_minute[4] and
       $str2time_last_minute[0] == $_[1] and
       $str2time_last_minute[1] == $_[2] and
       $str2time_last_minute[2] == $_[3] and
       $str2time_last_minute[3] == $_[4] and
       $str2time_last_minute[4] == $_[5])
    {
        return $str2time_last_minute_timestamp + $_[0];
    }
    my $time;
    if($GMT) {
        $time = timegm(@_);
    }
    else {
        $time = timelocal(@_);
    }
    @str2time_last_minute = @_[1..5];
    $str2time_last_minute_timestamp = $time-$_[0];
    return $time;
}

sub _use_locale($) {
    use POSIX qw(locale_h strftime);
    my $old_locale = setlocale(LC_TIME);
    for my $locale (@_) {
        croak "new(): wrong 'locale' value: '$locale'" unless setlocale(LC_TIME, $locale);
        for my $month (0..11) {
            $months_map{lc(strftime("%b", 0, 0, 0, 1, $month, 96))} = $month;
        }
    }
    setlocale(LC_TIME, $old_locale);
		}

sub new($$;%) {
    my ($class, $file, %data) = @_;
    croak "new() requires one argument: file" unless defined $file;
    %data = () unless %data;
    if(not defined $data{year}) {
        $data{year} = (localtime(time))[5]+1900;
    }
    $data{type} = 'syslog' unless defined $data{type};
    $data{_repeat} = 0;
    if(ref $file eq 'File::Tail') {
        $data{filetail} = 1;
        $data{file} = $file;
    }
    else {
        $data{file}=gensym;
        open($data{file}, "<$file") or croak "can't open $file: $!";
    }
    if(defined $data{locale}) {
        if(ref $data{locale} eq 'ARRAY') {
            _use_locale @{$data{locale}};
        }
        elsif(ref $data{locale} eq '') {
            _use_locale $data{locale};
        }
        else {
            croak "'locale' parameter must be scalar or array of scalars";
        }
    }
    return bless \%data, $class;
}

sub _year_increment($$) {
    my ($self, $mon) = @_;
    # year change
    if($mon==0) {
        $self->{year}++ if defined $self->{_last_mon} and $self->{_last_mon} == 11;
        $enable_year_decrement = 1;
    }
    elsif($mon == 11) {
        if($enable_year_decrement) {
            $self->{year}-- if defined $self->{_last_mon} and $self->{_last_mon} != 11;
        }
    }
    else {
        $enable_year_decrement = 0;
    }
    $self->{_last_mon} = $mon;
}

sub _next_line($) {
    my $self = shift;
    my $f = $self->{file};
    if(defined $self->{filetail}) {
        return $f->read;
    }
    else {
        return <$f>;
    }
	       }

sub next($) {
    my ($self) = @_;
    while($self->{_repeat}>0) {
        $self->{_repeat}--;
        return $self->{_repeat_data};
    }
  line: while(my $str = $self->_next_line()) {
      # when FDS starts up, it generates three lines at the top of its logs
      # that aren't in the same format as the rest of the logs.  The first
      # two start with whitespace, and the third is blank.
      next if $str =~ /^\s+/;
      next if $str =~ /^$/;

      $str =~ /^
	  \[(\d+)\/(\S+)\/\d+  # date - 1, 2
	  \:
	  (\d+)\:(\d+)\:(\d+)\s+[\-\+]\d+\]  # time - 3, 4, 5
	  \s+conn=\d+\s
	  (?:(?:op|fd)=-?\d+\s)?
	  (?:(?:fd|slot)=-?\d+\s)?
	  ([A-Z]*)              # operation - 6
	  \s?
	  (.*)                  # text - 7
	  $/x or do
      {
	  warn "WARNING: line not in FDS log format: $str";
	  next line;
      };
      my $mon = $months_map{lc($2)};
      defined $mon or croak "unknown month $1\n";
      $self->_year_increment($mon);
      # convert to unix time
      my $time = str2time($5, $4, $3, $1, $mon, $self->{year}-1900,
			  $self->{GMT});
      if (not $self->{allow_future}) {
	  # accept maximum one day in the present future
	  if($time - time > 86400) {
	      warn "WARNING: ignoring future date in log line: $str";
	      next line;
	  }
      }
      my ($op, $text) = ($6, $7);
      if($self->{arrayref}) {
	  $self->{_last_data}{$op} = [
	      $time,  # 0: timestamp 
	      $op,    # 1: op
	      $text,  # 2: text
	      ];
      } else {
	  $self->{_last_data}{$op} = {
	      timestamp => $time,
	      op        => $op,
	      text      => $text,
	  };
      }
      return $self->{_last_data}{$op};
  }
    return undef;
	 }

#####################################################################
#####################################################################
#####################################################################

use RRDs;
use strict;
use File::Tail;
use Getopt::Long;
use POSIX 'setsid';

my $VERSION = "1.0.0";

# config
my $rrdstep = 60;
my $xpoints = 540;
my $points_per_sample = 3;

my $pidfile = '/var/run/ds-graph.pid';
my $rrd_dir = '/var/lib/ds-graph';

# global variables
my $logfile;
my $fds_version;
my $instance;
my $ops_rrd = "fds_ops.rrd";
my $connxn_rrd = "fds_connxn.rrd";
my $year;
my $this_minute;
my %sum = ( add => 0, srch => 0, bind => 0, mod => 0, del => 0, ext => 0,
	    connxn => 0, ssl => 0, tls => 0);
my $rrd_inited=0;

my %opt = ();

# prototypes
sub daemonize();
sub process_line($);
sub init_rrd($);
sub update($);

Getopt::Long::Configure('no_ignore_case');
GetOptions(\%opt,
	   'help|h', 'logfile|l=s', 'year|y=i', 'daemon|d!', 'pidfile=s',
	   'rrddir=s', 'instance|I=s',
    ) or exit(1);
usage() if $opt{'help'};

$pidfile = $opt{'pidfile'} if defined $opt{'pidfile'};
$rrd_dir = $opt{'rrddir'}  if defined $opt{'rrddir'};

if($opt{daemon} or $opt{'rrddir'}) {
    chdir $rrd_dir or die "ds-graphd: can't chdir to $rrd_dir: $!";
    -w $rrd_dir or die "ds-graphd: can't write to $rrd_dir\n";
}

daemonize if $opt{daemon};

if ($opt{'logfile'}) {
    $logfile = $opt{'logfile'};
    warn "The -l (--logfile) option is deprecated; please use -I instead\n";
} else { # no logfile specified -- use the instance to figure it out
    if ($opt{'instance'}) {
	$instance = $opt{'instance'};
	if (-d "/var/log/dirsrv/slapd-$instance" &&
	    -r "/var/log/dirsrv/slapd-$instance") {
	    $fds_version = "1.1";
	} elsif (-d "/opt/fedora-ds/slapd-$instance" &&
		 -r "/opt/fedora-ds/slapd-$instance") {
	    $fds_version = "1.0";
	} else {
	    die "Could not read or locate logs in either /var/log/dirsrv/slapd-$instance or /opt/fedora-ds/slapd-$instance\n";
	}
    } else { # no instance specified on the command line
	# try to determine the instance
	if (-d "/opt/fedora-ds" && -r "/opt/fedora-ds") {
	    $fds_version = "1.0";
	} elsif (-d "/var/log/dirsrv" && -r "/var/log/dirsrv") {
	    $fds_version = "1.1";
	} else {
	    die "No installation of Fedora DS 1.0 (/opt/fedora-ds) or 1.1 (/var/log/dirsrv) found\n";
	}
	
	my $fdsroot;
	if ($fds_version eq '1.0') {
	    $fdsroot = "/opt/fedora-ds";
	} elsif ($fds_version eq '1.1') {
	    $fdsroot = "/var/log/dirsrv";
	}
	
	opendir(DIR, $fdsroot); # made sure it was readable earlier
	my $file;
	my @instances;
	while (defined($file = readdir(DIR))) {
	    push(@instances, $file) if $file =~ /^slapd-/;
	}
	closedir(DIR);
	
	if (scalar(@instances) == 1) {
	    $instance = shift(@instances);
	    $instance =~ s/^slapd-//;
	} elsif (scalar(@instances) == 0) {
	    die "No instance ($fdsroot/slapd-*) found in $fdsroot\n";
	} else { # scalar(@instances) > 1
	    warn "More than one instance of Fedora DS found in $fdsroot\n";
	    die "You must specify an instance on the command line with -I\n";
	}
    }
    
    if ($fds_version eq '1.0') {
	$logfile = "/opt/fedora-ds/slapd-$instance/logs/access";
    } elsif ($fds_version eq '1.1') {
	$logfile = "/var/log/dirsrv/slapd-$instance/access";
    }
}

my $file = File::Tail->new(name => $logfile, tail => -1);
my $parser = new Parse::FDSlog($file,
			       year => $opt{year},
			       arrayref => 1);

while(my $line = $parser->next()) {
    process_line($line);
}

sub usage {
    print "usage: ds-graphd [*options*]\n\n";
    print "  -h, --help          display this help and exit\n";
    print "  -V, --version       output version information and exit\n";
    print "  -I, --instance=INST specify instance; do not include the slapd-\n";                 
    print "  -l, --logfile=FILE  monitor FILE (deprecated; use -I)\n";
    print "  -y, --year          starting year of the log file (default: current year)\n";
    print "  -d, --daemon        start in the background\n";
    print "  --pidfile=FILE      write PID to FILE instead of /var/run/ds-graph.pid\n";
    print "  --rrddir=DIR        write RRDs to DIR instead of .\n";    
    exit;
}

sub daemonize() {
    open STDIN, '/dev/null' or die "ds-graphd: can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "ds-graphd: can't write to /dev/null: $!";
    defined(my $pid = fork) or die "ds-graphd: can't fork: $!";
    if ($pid) {
	# parent
	open PIDFILE, ">$pidfile"
	    or die "ds-graphd: can't write to $pidfile: $!\n";
	print PIDFILE "$pid\n";
	close(PIDFILE);
	exit;
    }
    # child
    setsid or die "ds-graphd: can't start a new session: $!";
    open STDERR, '>&STDOUT' or die "ds-graphd: can't dup stdout: $!";
}

sub init_rrd($) {
    my $m = shift;
    my $rows = $xpoints / $points_per_sample;
    my $realrows = int($rows * 1.1); # ensure that the full range is covered
    my $day_steps = int(3600 * 24 / ($rrdstep * $rows));
    # use multiples, otherwise rrdtool could choose the wrong RRA
    my $week_steps  = $day_steps   * 7;
    my $month_steps = $week_steps  * 5;
    my $year_steps  = $month_steps * 12;

    if(! -f $ops_rrd) {
	RRDs::create($ops_rrd, '--start', $m, '--step', $rrdstep,
		     'DS:add:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     'DS:srch:GAUGE:' . ($rrdstep * 2) . ':0:U',
		     'DS:bind:GAUGE:' . ($rrdstep * 2) . ':0:U',
		     'DS:mod:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     'DS:del:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     'DS:ext:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     "RRA:AVERAGE:0.5:$day_steps:$realrows",   # day
		     "RRA:AVERAGE:0.5:$week_steps:$realrows",  # week
		     "RRA:AVERAGE:0.5:$month_steps:$realrows", # month
		     "RRA:AVERAGE:0.5:$year_steps:$realrows",  # year
		     "RRA:MAX:0.5:$day_steps:$realrows",   # day
		     "RRA:MAX:0.5:$week_steps:$realrows",  # week
		     "RRA:MAX:0.5:$month_steps:$realrows", # month
		     "RRA:MAX:0.5:$year_steps:$realrows",  # year
	    );
	my $err = RRDs::error;
	warn "create of $ops_rrd failed: $err\n" if $err;
	$this_minute = $m;
    } elsif (-f $ops_rrd) {
	$this_minute = RRDs::last($ops_rrd) + $rrdstep;
    }    

    if(! -f $connxn_rrd) {
	RRDs::create($connxn_rrd, '--start', $m, '--step', $rrdstep,
		     'DS:connxn:GAUGE:' . ($rrdstep * 2) . ':0:U',
		     'DS:ssl:GAUGE:'    . ($rrdstep * 2) . ':0:U',
		     'DS:tls:GAUGE:'    . ($rrdstep * 2) . ':0:U',
		     "RRA:AVERAGE:0.5:$day_steps:$realrows",   # day
		     "RRA:AVERAGE:0.5:$week_steps:$realrows",  # week
		     "RRA:AVERAGE:0.5:$month_steps:$realrows", # month
		     "RRA:AVERAGE:0.5:$year_steps:$realrows",  # year
		     "RRA:MAX:0.5:$day_steps:$realrows",   # day
		     "RRA:MAX:0.5:$week_steps:$realrows",  # week
		     "RRA:MAX:0.5:$month_steps:$realrows", # month
		     "RRA:MAX:0.5:$year_steps:$realrows",  # year
	    );
	my $err = RRDs::error;
	warn "create of $connxn_rrd failed: $err\n" if $err;
	$this_minute = $m;
    } elsif (-f $connxn_rrd) {
	$this_minute = RRDs::last($connxn_rrd) + $rrdstep;
    }

    $rrd_inited = 1;
}

sub process_line($) {
    my $sl = shift;
    my $time = $sl->[0];
    my $op   = $sl->[1];
    my $text = $sl->[2];

    if ($op) {
	if ($op =~ /^ADD|SRCH|BIND|MOD|DEL$/) {
	    event($time, lc($op));
	} elsif ($op =~ /^EXT$/) {
	    event($time, 'ext');
	    event($time, 'tls') if $text =~ /oid="1\.3\.6\.1\.4\.1\.1466\.20037"/;
	}
    } else { # either a connect or disconnect
	if ($text =~ /^connection from/) {
	    event($time, 'connxn');
	} elsif ($text =~ /^SSL connection from/) {
	    event($time, 'ssl');
	}
    }
}

sub event($$) {
    my ($t, $type) = @_;
    update($t) and $sum{$type}++;
}

# returns 1 if $sum should be updated
sub update($) {
    my $t = shift;
    my $m = $t - $t % $rrdstep;
    init_rrd($m) unless $rrd_inited;
    return 1 if $m == $this_minute;
    return 0 if $m < $this_minute;

    RRDs::update $ops_rrd, "$this_minute:$sum{add}:$sum{srch}:$sum{bind}:$sum{mod}:$sum{del}:$sum{ext}";
    my $err = RRDs::error;
    warn "update of $ops_rrd failed: $err\n" if $err;

    RRDs::update $connxn_rrd, "$this_minute:$sum{connxn}:$sum{ssl}:$sum{tls}";
    $err = RRDs::error;
    warn "update of $connxn_rrd failed: $err\n" if $err;

    if ($m > $this_minute + $rrdstep) {
	for (my $sm = $this_minute + $rrdstep; $sm < $m; $sm += $rrdstep) {
	    RRDs::update $ops_rrd, "$sm:0:0:0:0";
	    RRDs::update $connxn_rrd, "$sm:0:0:0";
	}
    }
    $this_minute = $m;
    $sum{add} = 0;
    $sum{srch} = 0;
    $sum{bind} = 0;
    $sum{mod} = 0;
    $sum{del} = 0;
    $sum{ext} = 0;
    $sum{connxn} = 0;
    $sum{ssl} = 0;
    $sum{tls} = 0;
    return 1;
}
