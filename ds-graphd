#!/usr/bin/perl -w

# $Id$
#
# fedora-ds-graph -- An rrdtool-based graphing tool for Fedora DS statistics
# copyright (c) 2006-2008 Chris St. Pierre <chris.a.st.pierre@gmail.com>
# based on mailgraph copyright (c) 2000-2005 David Schweikert <dws@ee.ethz.ch>
# released under the GNU General Public License

######## Parse::FDSlog 0.2 ########
package Parse::FDSlog;
use Carp;
use Symbol;
use Time::Local;
use strict;
use vars qw($VERSION);
my %months_map = (
    'jan' => 0, 'feb' => 1, 'mar' => 2,
    'apr' => 3, 'may' => 4, 'jun' => 5,
    'jul' => 6, 'aug' => 7, 'sep' => 8,
    'oct' => 9, 'nov' =>10, 'dec' =>11,
    );

# year-increment algorithm: if in january, if december is seen, decrement year
my $enable_year_decrement = 1;

# fast timelocal, cache minute's timestamp
# don't cache more than minute because of daylight saving time switch
my @str2time_last_minute;
my $str2time_last_minute_timestamp;
# 0: sec, 1: min, 2: h, 3: day, 4: month, 5: year

sub str2time($$$$$$$) {
    my $GMT = pop @_;
    if(defined $str2time_last_minute[4] and
       $str2time_last_minute[0] == $_[1] and
       $str2time_last_minute[1] == $_[2] and
       $str2time_last_minute[2] == $_[3] and
       $str2time_last_minute[3] == $_[4] and
       $str2time_last_minute[4] == $_[5])
    {
        return $str2time_last_minute_timestamp + $_[0];
    }
    my $time;
    if($GMT) {
        $time = timegm(@_);
    }
    else {
        $time = timelocal(@_);
    }
    @str2time_last_minute = @_[1..5];
    $str2time_last_minute_timestamp = $time-$_[0];
    return $time;
}

sub new($$;%) {
    my ($class, $file, %data) = @_;
    croak "new() requires one argument: file" unless defined $file;
    %data = () unless %data;
    if (not defined($data{'year'})) {
        $data{'year'} = (localtime())[5] + 1900;
    }
    if (ref $file eq 'File::Tail') {
        $data{'filetail'} = 1;
        $data{'file'} = $file;
    } else {
        $data{'file'} = Symbol::gensym();
        open($data{'file'}, "<$file") or croak "can't open $file: $!";
    }
    return bless(\%data, $class);
}

sub _year_increment($$) {
    my ($self, $mon) = @_;
    # year change
    if ($mon == 0) {
        $self->{'year'}++
	    if defined($self->{'_last_mon'}) and $self->{'_last_mon'} == 11;
        $enable_year_decrement = 1;
    } elsif($mon == 11) {
        if($enable_year_decrement) {
            $self->{'year'}--
		if defined($self->{'_last_mon'}) and $self->{'_last_mon'} != 11;
        }
    } else {
        $enable_year_decrement = 0;
    }
    $self->{'_last_mon'} = $mon;
}

sub _next_line($) {
    my $self = shift;
    my $f = $self->{'file'};
    if(defined $self->{'filetail'}) {
        return $f->read();
    }
    else {
        return <$f>;
    }
}

sub next($) {
    my ($self) = @_;
  line: while(my $str = $self->_next_line()) {
      # when FDS starts up, it generates three lines at the top of its logs
      # that aren't in the same format as the rest of the logs.  The first
      # two start with whitespace, and the third is blank.
      next if $str =~ /^\s+/;
      next if $str =~ /^$/;

      $str =~ /^
	  \[(\d+)\/(\S+)\/\d+  # date - 1, 2
	  \:
	  (\d+)\:(\d+)\:(\d+)\s+[\-\+]\d+\]  # time - 3, 4, 5
	  \s+conn=\d+\s
	  (?:(?:op|fd)=-?\d+\s)?
	  (?:(?:fd|slot)=-?\d+\s)?
	  ([A-Z]*)              # operation - 6
	  \s?
	  (.*)                  # text - 7
	  $/x
	  or do {
	      warn "WARNING: line not in FDS log format: $str";
	      next line;
      };
      my $mon = $months_map{lc($2)};
      croak "unknown month $1\n" unless defined($mon);
      $self->_year_increment($mon);

      # convert to unix time
      my $time = str2time($5, $4, $3, $1, $mon, $self->{year}-1900,
			  $self->{'GMT'});
      # accept maximum one day in the present future
      if($time - time > 86400) {
	  warn "WARNING: ignoring future date in log line: $str\n";
	  next line;
      }
      my ($op, $text) = ($6, $7);
      $self->{'_last_data'}{$op} = [$time, $op, $text];
      return $self->{'_last_data'}{$op};
  }
    return undef;
}

#####################################################################
#####################################################################
#####################################################################

package main;

use RRDs;
use strict;
use File::Tail;
use Getopt::Long;
use POSIX 'setsid';

my $VERSION = "1.1.0";

# config
my $rrdstep = 60;
my $xpoints = 540;
my $points_per_sample = 3;

my $pidfile = '/var/run/ds-graph.pid';
my $rrd_dir = '/var/lib/ds-graph';

# global variables
my $logfile;
my $fds_version;
my $instance;
my $year;
my $this_minute;
my %sum = ( add => 0, srch => 0, bind => 0, mod => 0, del => 0, ext => 0,
	    cmp => 0, modrdn => 0,
	    connxn => 0, ssl => 0, tls => 0, sasl => 0, unsasl => 0);
my $rrd_inited=0;

my %opt = ();

# prototypes
sub daemonize();
sub process_line($);
sub init_rrd($);
sub update($);

Getopt::Long::Configure('no_ignore_case');
GetOptions(\%opt,
	   'help|h', 'logfile|l=s', 'year|y=i', 'daemon|d!', 'pidfile=s',
	   'rrddir=s', 'instance|I=s',
    ) or exit(1);
usage() if $opt{'help'};

$pidfile = $opt{'pidfile'} if defined $opt{'pidfile'};
$rrd_dir = $opt{'rrddir'}  if defined $opt{'rrddir'};

my $ops_rrd = "$rrd_dir/fds_ops.rrd";
my $connxn_rrd = "$rrd_dir/fds_connxn.rrd";

die "ds-graphd: can't write to $rrd_dir\n" unless -w $rrd_dir;

daemonize() if $opt{'daemon'};

if ($opt{'logfile'}) {
    $logfile = $opt{'logfile'};
} else { # no logfile specified -- use the instance to figure it out
    if ($opt{'instance'}) {
	$instance = $opt{'instance'};
	if (-d "/var/log/dirsrv/slapd-$instance" &&
	    -r "/var/log/dirsrv/slapd-$instance") {
	    $fds_version = "1.1";
	} elsif (-d "/opt/fedora-ds/slapd-$instance" &&
		 -r "/opt/fedora-ds/slapd-$instance") {
	    $fds_version = "1.0";
	} else {
	    die "Could not read or locate logs in either " .
		"/var/log/dirsrv/slapd-$instance or " .
		"/opt/fedora-ds/slapd-$instance\n";
	}
    } else { # no instance specified on the command line
	# try to determine the instance
	if (-d "/opt/fedora-ds" && -r "/opt/fedora-ds") {
	    $fds_version = "1.0";
	} elsif (-d "/var/log/dirsrv" && -r "/var/log/dirsrv") {
	    $fds_version = "1.1";
	} else {
	    die "No installation of Fedora DS 1.0 (/opt/fedora-ds) or 1.1 " .
		"(/var/log/dirsrv) found\n";
	}
	
	my $fdsroot;
	if ($fds_version eq '1.0') {
	    $fdsroot = "/opt/fedora-ds";
	} elsif ($fds_version eq '1.1') {
	    $fdsroot = "/var/log/dirsrv";
	}
	
	opendir(DIR, $fdsroot); # made sure it was readable earlier
	my $file;
	my @instances;
	while (defined($file = readdir(DIR))) {
	    push(@instances, $file) if $file =~ /^slapd-/;
	}
	closedir(DIR);
	
	if (scalar(@instances) == 1) {
	    $instance = shift(@instances);
	    $instance =~ s/^slapd-//;
	} elsif (scalar(@instances) == 0) {
	    die "No instance ($fdsroot/slapd-*) found in $fdsroot\n";
	} else { # scalar(@instances) > 1
	    warn "More than one instance of Fedora DS found in $fdsroot\n";
	    die "You must specify an instance on the command line with -I\n";
	}
    }
    
    if ($fds_version eq '1.0') {
	$logfile = "/opt/fedora-ds/slapd-$instance/logs/access";
    } elsif ($fds_version eq '1.1') {
	$logfile = "/var/log/dirsrv/slapd-$instance/access";
    }
}

my $file = File::Tail->new(name => $logfile, tail => -1);
my $parser = new Parse::FDSlog($file,
			       year => $opt{'year'},
			       arrayref => 1);

while(my $line = $parser->next()) {
    process_line($line);
}

sub usage {
    print "usage: ds-graphd [*options*]\n\n";
    print "  -h, --help          display this help and exit\n";
    print "  -I, --instance=INST FDS instance; do not include the slapd-\n";
    print "  -l, --logfile=FILE  monitor FILE (generally, use -I instead)\n";
    print "  -y, --year          starting year of the log file (default: current year)\n";
    print "  -d, --daemon        start in the background\n";
    print "  --pidfile=FILE      write PID to FILE instead of $pidfile\n";
    print "  --rrddir=DIR        write RRDs to DIR instead of $rrd_dir\n";    
    exit;
}

sub daemonize() {
    open STDIN, '/dev/null' or die "ds-graphd: can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "ds-graphd: can't write to /dev/null: $!";
    defined(my $pid = fork) or die "ds-graphd: can't fork: $!";
    if ($pid) {
	# parent
	open PIDFILE, ">$pidfile"
	    or die "ds-graphd: can't write to $pidfile: $!\n";
	print PIDFILE "$pid\n";
	close(PIDFILE);
	exit;
    }
    # child
    setsid or die "ds-graphd: can't start a new session: $!";
    open STDERR, '>&STDOUT' or die "ds-graphd: can't dup stdout: $!";
}

sub init_rrd($) {
    my $m = shift;
    my $rows = $xpoints / $points_per_sample;
    my $realrows = int($rows * 1.1); # ensure that the full range is covered
    my $day_steps = int(3600 * 24 / ($rrdstep * $rows));
    # use multiples, otherwise rrdtool could choose the wrong RRA
    my $week_steps  = $day_steps   * 7;
    my $month_steps = $week_steps  * 5;
    my $year_steps  = $month_steps * 12;

    if(! -f $ops_rrd) {
	RRDs::create($ops_rrd, '--start', $m, '--step', $rrdstep,
		     'DS:add:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     'DS:srch:GAUGE:' . ($rrdstep * 2) . ':0:U',
		     'DS:bind:GAUGE:' . ($rrdstep * 2) . ':0:U',
		     'DS:mod:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     'DS:del:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     'DS:ext:GAUGE:'  . ($rrdstep * 2) . ':0:U',
		     "RRA:AVERAGE:0.5:$day_steps:$realrows",   # day
		     "RRA:AVERAGE:0.5:$week_steps:$realrows",  # week
		     "RRA:AVERAGE:0.5:$month_steps:$realrows", # month
		     "RRA:AVERAGE:0.5:$year_steps:$realrows",  # year
		     "RRA:MAX:0.5:$day_steps:$realrows",   # day
		     "RRA:MAX:0.5:$week_steps:$realrows",  # week
		     "RRA:MAX:0.5:$month_steps:$realrows", # month
		     "RRA:MAX:0.5:$year_steps:$realrows",  # year
	    );
	my $err = RRDs::error;
	warn "create of $ops_rrd failed: $err\n" if $err;
	$this_minute = $m;
    } elsif (-f $ops_rrd) {
	# CMP and MODRDN op tracking added in v1.0.3;
	# upgrade old DBs if necessary
	foreach my $op (qw(cmp modrdn)) {
	    chomp(my $has_op = `rrdtool info $ops_rrd | grep -F 'ds[$op]' | wc -l`);
	    if (!$has_op) {
		add_ds($ops_rrd, $op, 'GAUGE', $rrdstep * 2, 0, 'U');
	    }
	}

	$this_minute = RRDs::last($ops_rrd) + $rrdstep;
    }    

    if (!-f $connxn_rrd) {
	RRDs::create($connxn_rrd, '--start', $m, '--step', $rrdstep,
		     'DS:connxn:GAUGE:' . ($rrdstep * 2) . ':0:U',
		     'DS:ssl:GAUGE:'    . ($rrdstep * 2) . ':0:U',
		     'DS:tls:GAUGE:'    . ($rrdstep * 2) . ':0:U',
		     'DS:sasl:GAUGE:'    . ($rrdstep * 2) . ':0:U',
		     "RRA:AVERAGE:0.5:$day_steps:$realrows",   # day
		     "RRA:AVERAGE:0.5:$week_steps:$realrows",  # week
		     "RRA:AVERAGE:0.5:$month_steps:$realrows", # month
		     "RRA:AVERAGE:0.5:$year_steps:$realrows",  # year
		     "RRA:MAX:0.5:$day_steps:$realrows",   # day
		     "RRA:MAX:0.5:$week_steps:$realrows",  # week
		     "RRA:MAX:0.5:$month_steps:$realrows", # month
		     "RRA:MAX:0.5:$year_steps:$realrows",  # year
	    );
	my $err = RRDs::error;
	warn "create of $connxn_rrd failed: $err\n" if $err;
	$this_minute = $m;
    } elsif (-f $connxn_rrd) {
	# TLS tracking added in v0.3, SASL bind tracking added in v1.0.2
	# upgrade old DBs if necessary
	foreach my $conn (qw(tls sasl)) {
	    chomp(my $has_conn = `rrdtool info $connxn_rrd | grep -F 'ds[$conn]' | wc -l`);
	    if (!$has_conn) {
		add_ds($connxn_rrd, $conn, 'GAUGE', $rrdstep * 2, 0, 'U');
	    }
	}

	$this_minute = RRDs::last($connxn_rrd) + $rrdstep;
    }

    $rrd_inited = 1;
}

# much code for add_ds taken from add_ds.pl,
# Copyright (C) 2000 Selena M. Brewington, covered under the GPL
sub add_ds($$$$$$) {
    my ($rrd, $ds, $type, $heartbeat, $llim, $ulim) = @_;
    
    if ($llim eq 'U') {
	$llim = 'NaN';
    }
    if ($ulim eq 'U') {
	$ulim = 'NaN';
    }

    # we export the RRD to XML, munge the XML, then re-import it
    
    # first, BACK UP THE RRD!
    system("cp $rrd $rrd.bak");

    # export to XML
    system("rrdtool dump $rrd $rrd.xml");
    open(IN, "$rrd.xml") or do {
	warn "Couldn't open $rrd.xml for read; conversion of RRD was not successful";
	return 0;
    };

    # open file to write munged XML to
    open(OUT, ">$rrd-fixed.xml") or do {
	warn "Couldn't open $rrd-fixed.xml for write: conversion of RRD was not successful";
	return 0;
    };

    my $cdp_prep_end = '</cdp_prep>';
    
    my $row_end = '</row>';
    my $name = '<name>';
    my $name_end = '</name>';
    
    my $field = '<v> NaN </v>';
    
    my $found_ds = 0;
    my $num_sources = 0;
    my $last;
    my $fields = " ";
    my $datasource;

    while (<IN>) {
	if (($_ =~ s/$row_end$/$fields$row_end/) && $found_ds) {
	    # need to hit <ds> types first, if we don't, we're screwed
	    print OUT; 
	} elsif (/$cdp_prep_end/) {
	    print OUT "\t\t\t<ds>\n";
	    print OUT "\t\t\t<primary_value> NaN </primary_value>\n";
	    print OUT "\t\t\t<secondary_value> NaN </secondary_value>\n";
	    print OUT "\t\t\t<value> 0.0000000000e+00 </value>\n";
	    print OUT "\t\t\t<unknown_datapoints> 0 </unknown_datapoints>\n";
	    print OUT "\t\t\t</ds>\n";
	    print OUT;
	} elsif (/$name_end$/) {
	    ($datasource) = /$name (\w+)/;
	    $found_ds++;
	    print OUT;
	} elsif (/Round Robin Archives/) {
	    # print out additional datasource definitions
	    ($num_sources) = ($datasource =~ /(\d+)/);

	    for (my $x = $num_sources; $x < $num_sources + 1; $x++) {
		$fields .= $field;
		print OUT "\n\t<ds>\n";
		print OUT "\t\t<name> $ds <\/name>\n";
		print OUT "\t\t<type> $type <\/type>\n";
		print OUT "\t\t<minimal_heartbeat> $heartbeat <\/minimal_heartbeat>\n";
		print OUT "\t\t<min> $llim <\/min>\n";
		print OUT "\t\t<max> $ulim <\/max>\n\n";
		print OUT "\t\t<!-- PDP Status-->\n";
		print OUT "\t\t<last_ds> 0 <\/last_ds>\n";
		print OUT "\t\t<value> 0.0000000000e+00 <\/value>\n";
		print OUT "\t\t<unknown_sec> 0 <\/unknown_sec>\n"; 
		print OUT "\t<\/ds>\n\n";
	    }
	    print OUT;
	} else {
	    print OUT;
	}
	
	$last = $_;
    }

    close(IN);
    close(OUT);

    # import from fixed XML
    unlink($rrd);
    system("rrdtool restore $rrd-fixed.xml $rrd");
}

sub process_line($) {
    my $sl = shift;
    my $time = $sl->[0];
    my $op   = $sl->[1];
    my $text = $sl->[2];

    if ($op) {
	if ($op =~ /^ADD|SRCH|MOD|DEL|CMP|MODRDN$/) {
	    event($time, lc($op));
	} elsif ($op =~ /^BIND$/) {
	    event($time, 'bind');
	    event($time, 'sasl') if $text =~ /^method=sasl/;
	} elsif ($op =~ /^RESULT$/ && $text =~ /^err=14 tag=97/) {
	    # SASL bind in progress
	    event($time, 'unsasl');
	} elsif ($op =~ /^EXT$/) {
	    event($time, 'ext');
	    event($time, 'tls')
		if $text =~ /oid="1\.3\.6\.1\.4\.1\.1466\.20037"/;
	} elsif ($op =~ /^SSL$/ && $text =~ /^connection from/) {
	    event($time, 'ssl');
	}
    } else { # either a connect or disconnect
	if ($text =~ /^connection from/) {
	    event($time, 'connxn');
	}
    }
}

sub event($$) {
    my ($t, $type) = @_;
    update($t) and $sum{$type}++;
}

# returns 1 if $sum should be updated
sub update($) {
    my $t = shift;
    my $m = $t - $t % $rrdstep;
    init_rrd($m) unless $rrd_inited;
    return 1 if $m == $this_minute;
    return 0 if $m < $this_minute;

    RRDs::update($ops_rrd,
		 $this_minute . ':' .
		 $sum{'add'} . ':' .
		 $sum{'srch'} . ':' .
		 $sum{'bind'} . ':' .
		 $sum{'mod'} . ':' .
		 $sum{'del'} . ':' .
		 $sum{'ext'} . ':' .
		 $sum{'cmp'} . ':' .
		 $sum{'modrdn'});
    my $err = RRDs::error;
    warn "update of $ops_rrd failed: $err\n" if $err;

    # since TLS connections are initialized with the StartTLS EXT operation,
    # and SASL connections are initialized at BIND time, they get counted
    # as _both_ plaintext _and_ TLS or SASL.  (E.g., one count for the initial
    # connection, which is plaintext at that time, and one count later when
    # the connection is secured.)  Although the code here counts TLS and
    # SASL connections twice -- thus inflating the 'connxn' counter -- that
    # inflation is undone when the graph is drawn.
    #
    # this should be corrected, but tuning the data in an RRD like that would
    # be difficult.  As it stands, existing Fedora DS Graph users already have
    # lots of data in this format, so we're stuck with this for a while at
    # least.
    RRDs::update($connxn_rrd,
		 $this_minute . ':' .
		 $sum{'connxn'} . ':' .
		 $sum{'ssl'} . ':' .
		 $sum{'tls'} . ':' .
		 ($sum{'sasl'} - $sum{'unsasl'}));
    $err = RRDs::error;
    warn "update of $connxn_rrd failed: $err\n" if $err;

    if ($m > $this_minute + $rrdstep) {
	for (my $sm = $this_minute + $rrdstep; $sm < $m; $sm += $rrdstep) {
	    RRDs::update($ops_rrd, "$sm:0:0:0:0:0:0:0:0");
	    RRDs::update($connxn_rrd, "$sm:0:0:0:0");
	}
    }
    $this_minute = $m;
    $sum{'add'} = 0;
    $sum{'srch'} = 0;
    $sum{'bind'} = 0;
    $sum{'mod'} = 0;
    $sum{'del'} = 0;
    $sum{'ext'} = 0;
    $sum{'cmp'} = 0;
    $sum{'modrdn'} = 0;
    $sum{'connxn'} = 0;
    $sum{'sasl'} = 0;
    $sum{'unsasl'} = 0;
    $sum{'ssl'} = 0;
    $sum{'tls'} = 0;
    return 1;
}
